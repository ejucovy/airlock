{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Airlock","text":"<p>Express side effects anywhere. Control whether &amp; when they escape.</p>"},{"location":"#30-second-pitch","title":"30 Second Pitch","text":"<p>Stop worrying about where you call <code>.delay()</code>. Write your domain logic naturally, then control side effects at the boundary:</p> <pre><code>import airlock\n\nclass Order:\n    def process(self):\n        self.status = \"processed\"\n        self.save()\n        airlock.enqueue(notify_warehouse, self.id)\n        airlock.enqueue(send_confirmation_email, self.id)\n</code></pre> <p>The execution context decides what happens:</p> <pre><code># Production: side effects escape\nwith airlock.scope():\n    order.process()\n\n# Migration: suppress everything\nwith airlock.scope(policy=airlock.DropAll()):\n    order.process()\n\n# Test: fail if side effects attempted\nwith airlock.scope(policy=airlock.AssertNoEffects()):\n    test_pure_logic()\n</code></pre>"},{"location":"#get-started-choose-your-path","title":"Get Started (Choose Your Path)","text":"<ul> <li> <p> Raw Python</p> <p>Just Python, no framework needed</p> <p> 5 minute quickstart</p> </li> <li> <p> Django</p> <p>Auto-scoping with middleware, transaction-aware</p> <p> 5 minute quickstart</p> </li> <li> <p> Celery</p> <p>Wrap tasks, migrate <code>.delay()</code> calls</p> <p> 5 minute quickstart</p> </li> </ul>"},{"location":"#what-problem-does-this-solve","title":"What Problem Does This Solve?","text":"<p>Side effects in models/services are dangerous:</p> <pre><code>class Order:\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        send_email.delay(self.id)  # Fires EVERYWHERE\n</code></pre> <ul> <li>\u274c Migrations trigger emails</li> <li>\u274c Tests require mocking</li> <li>\u274c Bulk operations explode</li> <li>\u274c No control at call site</li> </ul> <p>With airlock, effects are buffered and escape where you decide:</p> <pre><code>class Order:\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        airlock.enqueue(send_email, self.id)  # Buffered\n</code></pre> <ul> <li>\u2705 Test scopes suppress effects</li> <li>\u2705 Migrations use <code>DropAll()</code> policy</li> <li>\u2705 Production flushes at request boundary</li> <li>\u2705 Full control + visibility</li> </ul> <p>Understand the problem \u2192</p>"},{"location":"#how-it-works-3-concerns","title":"How It Works (3 Concerns)","text":"<p>Airlock separates three orthogonal concerns:</p> Concern Controlled By Question WHEN Scope When do effects escape? (end of request, after commit) WHAT Policy Which effects execute? (all, none, filtered) HOW Executor How do they run? (sync, Celery, django-q) <p>Mix and match freely:</p> <pre><code># Django transaction + Celery dispatch + logging\nwith airlock.scope(\n    _cls=DjangoScope,              # WHEN: after transaction.on_commit()\n    executor=celery_executor,      # HOW: via Celery\n    policy=LogOnFlush()            # WHAT: log everything\n):\n    do_stuff()\n</code></pre> <p>Learn the core model \u2192</p>"},{"location":"#when-you-dont-need-this","title":"When You DON'T Need This","text":"<p>You're fine without airlock if:</p> <ul> <li>\u2705 All <code>.delay()</code> calls are in views (never models/services)</li> <li>\u2705 Tasks never chain (no task \u2192 task)</li> <li>\u2705 You're happy with constraints above</li> </ul> <p>That's a valid architecture. Airlock is for when you want effects closer to domain logic without losing control.</p> <p>See alternatives \u2192</p>"},{"location":"alternatives/","title":"Alternatives to Airlock","text":"<p>Airlock isn't always the right choice. Here are alternatives and when to use them.</p>"},{"location":"alternatives/#transactionon_commit","title":"<code>transaction.on_commit()</code>","text":"<p>Django's built-in way to defer execution until transaction commits:</p> <pre><code>from django.db import transaction\n\nclass Order(models.Model):\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        transaction.on_commit(lambda: notify_warehouse.delay(self.id))\n</code></pre>"},{"location":"alternatives/#when-this-works","title":"When This Works","text":"<ul> <li>You only care about transaction boundaries</li> <li>You're okay with limited introspection</li> <li>You use <code>ATOMIC_REQUESTS</code> consistently</li> </ul>"},{"location":"alternatives/#limitations","title":"Limitations","text":"<ul> <li>Only works in transactions - If no transaction, runs immediately</li> <li>No opt-out - Migrations, fixtures trigger callbacks</li> <li>No introspection - Can't inspect what's queued</li> <li>No policy control - Can't block specific tasks</li> <li>Confusing with nested transactions - Savepoints complicate behavior</li> </ul> <p>Airlock gives you <code>on_commit</code> behavior (via <code>DjangoScope</code>) plus policies, introspection, and unified dispatch.</p>"},{"location":"alternatives/#django-signals","title":"Django Signals","text":"<p>Signals move where code lives, not when it executes:</p> <pre><code>from django.db.models.signals import post_save\n\n@receiver(post_save, sender=Order)\ndef notify_on_order_save(sender, instance, **kwargs):\n    if instance.status == \"shipped\":\n        notify_warehouse.delay(instance.id)\n</code></pre>"},{"location":"alternatives/#when-this-works_1","title":"When This Works","text":"<ul> <li>You want to decouple handlers from models</li> <li>Multiple independent handlers for same event</li> <li>Event-driven architecture</li> </ul>"},{"location":"alternatives/#limitations_1","title":"Limitations","text":"<ul> <li>Doesn't solve timing - Tasks still fire immediately</li> <li>Doesn't solve opt-out - Migrations still trigger signals</li> <li>Implicit coupling - Hard to find all handlers</li> </ul> <p>Signals are orthogonal to airlock. You can use signals to trigger <code>airlock.enqueue()</code>.</p>"},{"location":"alternatives/#celery-chordschains","title":"Celery Chords/Chains","text":"<p>Define workflow upfront:</p> <pre><code>from celery import chain, chord\n\n# Sequential\nworkflow = chain(task_a.s(), task_b.s(), task_c.s())\nworkflow.apply_async()\n\n# Parallel then collect\ncallback = collect_results.s()\nworkflow = chord([task_a.s(), task_b.s(), task_c.s()])(callback)\n</code></pre>"},{"location":"alternatives/#when-this-works_2","title":"When This Works","text":"<ul> <li>Workflow is known upfront</li> <li>Tasks don't dynamically trigger others</li> <li>You want explicit DAG</li> </ul>"},{"location":"alternatives/#limitations_2","title":"Limitations","text":"<ul> <li>Can't handle dynamic workflows - Tasks that conditionally trigger others</li> <li>Doesn't help with models - Still need to decide where to start the chain</li> </ul> <p>Airlock helps when triggers are deep in the call stack, workflow is dynamic/conditional, or you can't hoist to the edge easily.</p>"},{"location":"alternatives/#edge-only-pattern-no-airlock","title":"Edge-Only Pattern (No Airlock)","text":"<p>Keep all <code>.delay()</code> calls in views:</p> <pre><code># Model stays pure\nclass Order(models.Model):\n    def mark_shipped(self):\n        self.status = \"shipped\"\n        self.save()\n\n# View handles side effects\ndef ship_order(request, order_id):\n    order = Order.objects.get(id=order_id)\n    order.mark_shipped()\n\n    notify_warehouse.delay(order.id)\n    send_confirmation.delay(order.id)\n\n    return HttpResponse(\"OK\")\n</code></pre> <p>This is a valid architecture. Airlock is for when you want to express intent closer to domain logic.</p>"},{"location":"alternatives/#when-not-to-use-airlock","title":"When NOT to Use Airlock","text":"<p>Skip airlock if you're happy with edge-only pattern and your team prefers explicit over encapsulated.</p>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>Core patterns for everyday use.</p>"},{"location":"guide/basic-usage/#the-basic-pattern","title":"The Basic Pattern","text":"<pre><code>import airlock\n\n# 1. Express intent with airlock.enqueue()\ndef process_order(order_id):\n    order = get_order(order_id)\n    order.status = \"processed\"\n    save(order)\n\n    airlock.enqueue(notify_warehouse, order_id=order_id)\n    airlock.enqueue(send_confirmation, order_id=order_id)\n\n# 2. Wrap in a scope\nwith airlock.scope():\n    process_order(123)\n# Effects dispatch here\n</code></pre>"},{"location":"guide/basic-usage/#scope-lifecycle","title":"Scope Lifecycle","text":"<p>On normal exit: calls <code>flush()</code> - intents dispatch</p> <p>On exception: calls <code>discard()</code> - intents dropped</p> <pre><code>with airlock.scope():\n    airlock.enqueue(task_a)\n    raise Exception()  # Scope discards, task_a doesn't run\n</code></pre>"},{"location":"guide/basic-usage/#local-policy-context","title":"Local Policy Context","text":"<p>Apply policy to a region without creating a new scope:</p> <pre><code>with airlock.scope():\n    airlock.enqueue(task_a)  # Will dispatch\n\n    with airlock.policy(airlock.DropAll()):\n        airlock.enqueue(task_b)  # Won't dispatch\n\n    airlock.enqueue(task_c)  # Will dispatch\n</code></pre> <p>All three intents go to the same buffer. Policy is captured per-intent.</p>"},{"location":"guide/basic-usage/#inspecting-the-buffer","title":"Inspecting the Buffer","text":"<pre><code>with airlock.scope() as s:\n    do_stuff()\n\n    # Check what's buffered\n    for intent in s.intents:\n        print(f\"{intent.name}: {intent.args}, {intent.kwargs}\")\n</code></pre>"},{"location":"guide/basic-usage/#pass-dispatch-options","title":"Pass Dispatch Options","text":"<pre><code>airlock.enqueue(\n    send_email,\n    user_id=123,\n    _dispatch_options={\"countdown\": 60, \"queue\": \"emails\"}\n)\n</code></pre> <p>Options are executor-specific (Celery, django-q, etc.)</p>"},{"location":"guide/basic-usage/#get-current-scope","title":"Get Current Scope","text":"<pre><code>scope = airlock.get_current_scope()\nif scope:\n    print(f\"In scope with {len(scope.intents)} intents buffered\")\n</code></pre>"},{"location":"guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>No scope:</p> <pre><code>airlock.enqueue(task)  # Raises NoScopeError\n</code></pre> <p>This is intentional - side effects require explicit boundaries.</p> <p>Policy violation:</p> <pre><code>with airlock.scope(policy=airlock.AssertNoEffects()):\n    airlock.enqueue(task)  # Raises PolicyViolation immediately\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Policies - Built-in and custom policies</li> <li>Nested scopes - Composition patterns</li> <li>Dispatch - Executors and options</li> </ul>"},{"location":"quickstart/celery/","title":"Celery Quickstart","text":"<p>Goal: Get airlock working with Celery tasks in 5 minutes.</p>"},{"location":"quickstart/celery/#install","title":"Install","text":"<pre><code>pip install airlock celery\n</code></pre>"},{"location":"quickstart/celery/#wrap-task-execution","title":"Wrap Task Execution","text":"<p>Use <code>AirlockTask</code> as base class to auto-scope task execution:</p> <pre><code>from celery import Celery\nfrom airlock.integrations.celery import AirlockTask\nimport airlock\n\napp = Celery('myapp')\n\n@app.task(base=AirlockTask)\ndef process_order(order_id):\n    order = fetch_order(order_id)\n    order.status = \"processed\"\n    save_order(order)\n\n    # These are buffered within the task's scope\n    airlock.enqueue(send_email, order_id=order_id)\n    airlock.enqueue(update_analytics, order_id=order_id)\n    # Flushes when task completes successfully\n    # Discards if task raises exception\n</code></pre> <p>Now when <code>process_order</code> runs: - \u2705 Creates automatic scope - \u2705 Flushes on success - \u274c Discards on error</p>"},{"location":"quickstart/celery/#dispatch-via-celery","title":"Dispatch via Celery","text":"<p>Use <code>celery_executor</code> to dispatch through Celery:</p> <pre><code>from airlock.integrations.executors.celery import celery_executor\n\nwith airlock.scope(executor=celery_executor):\n    airlock.enqueue(send_email, user_id=123)\n    airlock.enqueue(process_data, item_id=456)\n# Dispatches via .delay()\n</code></pre> <p>The executor automatically detects Celery tasks and uses <code>.delay()</code> or <code>.apply_async()</code>. Plain functions run synchronously.</p>"},{"location":"quickstart/celery/#combining-both","title":"Combining Both","text":"<p>Task execution scoping + Celery dispatch:</p> <pre><code>@app.task(base=AirlockTask)\ndef process_order(order_id):\n    # This task runs in a scope\n    order = fetch_order(order_id)\n    save_order(order)\n\n    # Dispatch follow-up task via Celery\n    airlock.enqueue(send_email, order_id=order_id)\n\n# Trigger it\nwith airlock.scope(executor=celery_executor):\n    airlock.enqueue(process_order, order_id=123)\n# process_order.delay(order_id=123) is called\n# When it runs, send_email is also queued via Celery\n</code></pre>"},{"location":"quickstart/celery/#pass-celery-options","title":"Pass Celery Options","text":"<pre><code>airlock.enqueue(\n    send_email,\n    user_id=123,\n    _dispatch_options={\n        \"countdown\": 60,      # Delay 60 seconds\n        \"queue\": \"emails\",    # Use specific queue\n        \"priority\": 9,        # High priority\n    }\n)\n# Calls: send_email.apply_async((user_id,), {}, countdown=60, queue=\"emails\", priority=9)\n</code></pre>"},{"location":"quickstart/celery/#migrating-existing-code","title":"Migrating Existing Code","text":""},{"location":"quickstart/celery/#selective-migration","title":"Selective Migration","text":"<p>Apply <code>LegacyTaskShim</code> to tasks you're migrating:</p> <pre><code>from airlock.integrations.celery import LegacyTaskShim\n\n@app.task(base=LegacyTaskShim)\ndef old_task(arg):\n    ...\n\n# This now routes through airlock\nwith airlock.scope():\n    old_task.delay(123)  # Emits DeprecationWarning, buffers intent\n# Dispatches here\n</code></pre> <p>Note: <code>LegacyTaskShim</code> requires an active scope. It will raise <code>NoScopeError</code> if called outside a scope.</p>"},{"location":"quickstart/celery/#blanket-migration","title":"Blanket Migration","text":"<p>For large codebases, intercept all tasks globally:</p> <pre><code># celery.py\nfrom celery import Celery\nfrom airlock.integrations.celery import install_global_intercept\n\napp = Celery('myapp')\n\n# Patch all tasks globally\ninstall_global_intercept(app)\n</code></pre> <p>This: 1. Intercepts all <code>.delay()</code> and <code>.apply_async()</code> calls 2. Routes them through airlock when inside a scope 3. Wraps all task execution in scopes (like <code>AirlockTask</code>) 4. Emits <code>DeprecationWarning</code> to encourage migration</p> <p>Inside scope: <pre><code>with airlock.scope():\n    my_task.delay(123)  # Buffered, returns None\n# Dispatches here\n</code></pre></p> <p>Outside scope: <pre><code>my_task.delay(123)  # Passes through to Celery, warns\n</code></pre></p> <p>\u26a0\ufe0f Global intercept is a migration tool, not steady state. Use it to migrate legacy code, but prefer <code>airlock.enqueue()</code> for new code.</p> <p>Full migration guide \u2192</p>"},{"location":"quickstart/celery/#with-django","title":"With Django","text":"<p>Combine Django middleware + Celery executor:</p> <pre><code># settings.py\nMIDDLEWARE = [\n    \"airlock.integrations.django.AirlockMiddleware\",\n]\n\nAIRLOCK = {\n    \"TASK_BACKEND\": \"airlock.integrations.executors.celery.celery_executor\",\n}\n</code></pre> <p>Now every request auto-scopes and dispatches via Celery:</p> <pre><code>import airlock\n\ndef checkout_view(request):\n    order = process_checkout(request)\n    airlock.enqueue(send_confirmation, order_id=order.id)\n    airlock.enqueue(notify_warehouse, order_id=order.id)\n    return HttpResponse(\"OK\")\n# Both tasks dispatch via Celery after transaction.on_commit()\n</code></pre>"},{"location":"quickstart/celery/#next-steps","title":"Next Steps","text":"<ul> <li>Migration strategies - Selective vs blanket</li> <li>Task wrapper details - AirlockTask deep dive</li> <li>Raw Python quickstart - Core concepts without frameworks</li> </ul>"},{"location":"quickstart/django/","title":"Django Quickstart","text":"<p>Goal: Get airlock working in Django in 5 minutes with automatic request scoping.</p>"},{"location":"quickstart/django/#install","title":"Install","text":"<pre><code>pip install airlock\n</code></pre>"},{"location":"quickstart/django/#setup","title":"Setup","text":"<p>Add middleware to <code>settings.py</code>:</p> <pre><code>MIDDLEWARE = [\n    # ... other middleware ...\n    \"airlock.integrations.django.AirlockMiddleware\",\n]\n</code></pre> <p>Done. Every request now has automatic scoping.</p>"},{"location":"quickstart/django/#how-it-works","title":"How It Works","text":"<p>The middleware automatically wraps each request in a scope:</p> <ul> <li>\u2705 Flushes on success (1xx/2xx/3xx responses)</li> <li>\u274c Discards on error (4xx/5xx or exception)</li> <li>\ud83d\udd04 Defers to <code>transaction.on_commit()</code> automatically</li> </ul>"},{"location":"quickstart/django/#basic-usage","title":"Basic Usage","text":"<p>In your models/views/services, replace <code>.delay()</code> with <code>airlock.enqueue()</code>:</p> <pre><code>import airlock\n\nclass Order(models.Model):\n    def process(self):\n        self.status = \"processed\"\n        self.save()\n        airlock.enqueue(send_confirmation_email, order_id=self.id)\n        airlock.enqueue(notify_warehouse, order_id=self.id)\n\n# In view\ndef checkout(request):\n    order = Order.objects.get(id=request.POST['order_id'])\n    order.process()\n    return HttpResponse(\"OK\")\n# Side effects dispatch here after response + transaction commit\n</code></pre>"},{"location":"quickstart/django/#configuration","title":"Configuration","text":"<p>Optional settings:</p> <pre><code># settings.py\nAIRLOCK = {\n    # Use Celery for dispatch\n    \"TASK_BACKEND\": \"airlock.integrations.executors.celery.celery_executor\",\n\n    # Or use django-q\n    # \"TASK_BACKEND\": \"airlock.integrations.executors.django_q.django_q_executor\",\n\n    # Defer to transaction.on_commit() (default: True)\n    \"USE_ON_COMMIT\": True,\n\n    # Database for on_commit (default: \"default\")\n    \"DATABASE_ALIAS\": \"default\",\n}\n</code></pre> <p>Without <code>TASK_BACKEND</code>, tasks run synchronously. Set it to use your queue.</p>"},{"location":"quickstart/django/#management-commands","title":"Management Commands","text":"<p>Wrap commands with <code>@airlock_command</code> for automatic scoping:</p> <pre><code>from django.core.management.base import BaseCommand\nfrom airlock.integrations.django import airlock_command\n\nclass Command(BaseCommand):\n    def add_arguments(self, parser):\n        parser.add_argument('--dry-run', action='store_true')\n\n    @airlock_command\n    def handle(self, *args, **options):\n        # If --dry-run, all side effects dropped automatically\n        Order.objects.filter(status='pending').update(status='processed')\n</code></pre> <p>The decorator: - Creates scope for command - Respects <code>--dry-run</code> (uses <code>DropAll()</code> policy) - Flushes on success, discards on error</p>"},{"location":"quickstart/django/#manual-scoping","title":"Manual Scoping","text":"<p>Sometimes you need explicit control outside requests:</p> <pre><code>from airlock.integrations.django import DjangoScope\n\n# In a Celery task, cron job, etc.\ndef background_job():\n    with airlock.scope(_cls=DjangoScope):\n        do_stuff()\n    # Effects dispatch after transaction commit\n</code></pre>"},{"location":"quickstart/django/#testing","title":"Testing","text":""},{"location":"quickstart/django/#suppress-side-effects-in-tests","title":"Suppress side effects in tests","text":"<pre><code>from django.test import TestCase\nimport airlock\n\nclass OrderTest(TestCase):\n    def test_processing_logic(self):\n        with airlock.scope(policy=airlock.AssertNoEffects()):\n            # Test pure business logic without side effects\n            order = Order.objects.create(...)\n            order.process()\n        # Would raise if any airlock.enqueue() called\n</code></pre>"},{"location":"quickstart/django/#inspect-buffered-effects","title":"Inspect buffered effects","text":"<pre><code>def test_correct_emails_sent(self):\n    with airlock.scope() as s:\n        order.process()\n\n        # Verify what was enqueued\n        assert len(s.intents) == 2\n        assert s.intents[0].task.__name__ == \"send_confirmation_email\"\n        assert s.intents[1].task.__name__ == \"notify_warehouse\"\n    # Can verify without actually sending emails\n</code></pre>"},{"location":"quickstart/django/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/django/#suppress-emails-in-admin","title":"Suppress emails in admin","text":"<pre><code># myapp/middleware.py\nfrom airlock.integrations.django import AirlockMiddleware\nimport airlock\n\nclass AdminAirlockMiddleware(AirlockMiddleware):\n    def get_policy(self, request):\n        if request.path.startswith('/admin/'):\n            return airlock.BlockTasks({\"send_confirmation_email\"})\n        return super().get_policy(request)\n</code></pre>"},{"location":"quickstart/django/#custom-flush-behavior","title":"Custom flush behavior","text":"<pre><code>class MyAirlockMiddleware(AirlockMiddleware):\n    def should_flush(self, request, response):\n        # Only flush on 2xx (not 3xx redirects)\n        return 200 &lt;= response.status_code &lt; 300\n</code></pre>"},{"location":"quickstart/django/#with-django-q","title":"With django-q","text":"<p>Using django-q as your task backend:</p> <pre><code># settings.py\nAIRLOCK = {\n    \"TASK_BACKEND\": \"airlock.integrations.executors.django_q.django_q_executor\",\n}\n</code></pre> <p>Now all <code>airlock.enqueue()</code> calls dispatch via <code>async_task()</code>:</p> <pre><code>def process_order(order_id):\n    # Plain function, no decorator needed\n    order = Order.objects.get(id=order_id)\n    order.status = \"processed\"\n    order.save()\n\n# In view/command\nwith transaction.atomic():\n    order.save()\n    airlock.enqueue(process_order, order_id=order.id)\n# Dispatches via async_task() after commit\n</code></pre> <p>Pass django-q options:</p> <pre><code>airlock.enqueue(\n    heavy_task,\n    data=payload,\n    _dispatch_options={\n        \"group\": \"heavy-jobs\",\n        \"timeout\": 300,\n        \"hook\": \"my_app.tasks.cleanup_hook\"\n    }\n)\n</code></pre>"},{"location":"quickstart/django/#next-steps","title":"Next Steps","text":"<ul> <li>Using with Celery - Celery integration</li> <li>Migration guide - Migrate existing code</li> <li>Nested scopes - Transaction boundaries</li> <li>Custom policies - Write your own policies</li> </ul>"},{"location":"quickstart/raw-python/","title":"Raw Python Quickstart","text":"<p>Goal: Get airlock working in 5 minutes without any framework.</p>"},{"location":"quickstart/raw-python/#install","title":"Install","text":"<pre><code>pip install airlock\n</code></pre>"},{"location":"quickstart/raw-python/#basic-pattern","title":"Basic Pattern","text":"<pre><code>import airlock\n\n# 1. Use airlock.enqueue() instead of direct calls\ndef process_order(order_id):\n    order = fetch_order(order_id)\n    order.status = \"processed\"\n    save_order(order)\n\n    airlock.enqueue(send_email, order_id=order_id)\n    airlock.enqueue(notify_warehouse, order_id=order_id)\n\n# 2. Wrap execution in a scope\nwith airlock.scope():\n    process_order(123)\n# Side effects dispatch here when scope exits\n</code></pre> <p>That's it. Effects buffer during execution, dispatch at scope exit.</p>"},{"location":"quickstart/raw-python/#controlling-behavior","title":"Controlling Behavior","text":""},{"location":"quickstart/raw-python/#drop-everything-dry-run-mode","title":"Drop everything (dry-run mode)","text":"<pre><code>with airlock.scope(policy=airlock.DropAll()):\n    process_order(123)\n# Nothing dispatches\n</code></pre>"},{"location":"quickstart/raw-python/#assert-no-side-effects-testing","title":"Assert no side effects (testing)","text":"<pre><code>def test_pure_calculation():\n    with airlock.scope(policy=airlock.AssertNoEffects()):\n        result = calculate_total(cart)  # OK\n        airlock.enqueue(send_email)     # Raises PolicyViolation\n</code></pre>"},{"location":"quickstart/raw-python/#block-specific-tasks","title":"Block specific tasks","text":"<pre><code>with airlock.scope(policy=airlock.BlockTasks({\"send_email\"})):\n    process_order(123)\n# notify_warehouse dispatches, send_email doesn't\n</code></pre>"},{"location":"quickstart/raw-python/#inspect-before-dispatch","title":"Inspect before dispatch","text":"<pre><code>with airlock.scope() as s:\n    process_order(123)\n\n    # Check what's buffered\n    print(f\"Buffered {len(s.intents)} side effects:\")\n    for intent in s.intents:\n        print(f\"  - {intent.name}\")\n# Dispatches here\n</code></pre>"},{"location":"quickstart/raw-python/#using-task-queues","title":"Using Task Queues","text":""},{"location":"quickstart/raw-python/#with-celery","title":"With Celery","text":"<pre><code>from airlock.integrations.executors.celery import celery_executor\n\nwith airlock.scope(executor=celery_executor):\n    airlock.enqueue(celery_task, arg=123)\n# Dispatches via celery_task.delay(arg=123)\n</code></pre>"},{"location":"quickstart/raw-python/#with-django-q","title":"With django-q","text":"<pre><code>from airlock.integrations.executors.django_q import django_q_executor\n\nwith airlock.scope(executor=django_q_executor):\n    airlock.enqueue(any_function, arg=123)\n# Dispatches via async_task(any_function, arg=123)\n</code></pre>"},{"location":"quickstart/raw-python/#common-patterns","title":"Common Patterns","text":""},{"location":"quickstart/raw-python/#local-policy-override","title":"Local policy override","text":"<pre><code>with airlock.scope():\n    airlock.enqueue(task_a)  # Will dispatch\n\n    with airlock.policy(airlock.DropAll()):\n        airlock.enqueue(task_b)  # Won't dispatch\n\n    airlock.enqueue(task_c)  # Will dispatch\n# task_a and task_c dispatch, task_b dropped\n</code></pre>"},{"location":"quickstart/raw-python/#pass-dispatch-options","title":"Pass dispatch options","text":"<pre><code>airlock.enqueue(\n    send_email,\n    user_id=123,\n    _dispatch_options={\"countdown\": 60, \"queue\": \"emails\"}\n)\n# Options passed to underlying queue (Celery, etc)\n</code></pre>"},{"location":"quickstart/raw-python/#next-steps","title":"Next Steps","text":"<ul> <li>Understand the problem - Why airlock exists</li> <li>Policies guide - Built-in and custom policies</li> <li>Nested scopes - Composition and capture</li> <li>Celery integration - Wrap Celery tasks</li> </ul>"},{"location":"understanding/core-model/","title":"Core Model: The 3 Concerns","text":"<p>Airlock separates three orthogonal concerns. Understanding this makes everything else obvious.</p>"},{"location":"understanding/core-model/#the-three-concerns","title":"The Three Concerns","text":"Concern Controlled By Question WHEN Scope When do effects escape? WHAT Policy Which effects execute? HOW Executor How do they run? <p>These are independent and can be mixed freely.</p>"},{"location":"understanding/core-model/#concern-1-when-scope","title":"Concern 1: WHEN (Scope)","text":"<p>Scopes control timing and lifecycle.</p> <pre><code># Basic scope: flush on success, discard on error\nwith airlock.scope():\n    do_stuff()\n    # Effects buffered...\n# Effects execute here (on normal exit)\n</code></pre> <pre><code># Transaction-aware scope: wait for commit\nfrom airlock.integrations.django import DjangoScope\n\nwith transaction.atomic():\n    with airlock.scope(_cls=DjangoScope):\n        order.save()\n        airlock.enqueue(send_email, order.id)\n    # Effects still buffered...\n# Effects execute here (after commit)\n</code></pre>"},{"location":"understanding/core-model/#scope-decides","title":"Scope decides:","text":"<ul> <li>When to flush (end of block, after commit, custom)</li> <li>Whether to flush (success vs error)</li> <li>How to store buffer (memory, database, etc.)</li> </ul> <p>Default: flush on normal exit, discard on exception.</p>"},{"location":"understanding/core-model/#concern-2-what-policy","title":"Concern 2: WHAT (Policy)","text":"<p>Policies filter and observe intents.</p> <pre><code># Drop all effects (dry-run)\nwith airlock.scope(policy=airlock.DropAll()):\n    process_orders()  # Effects buffered but never dispatched\n\n# Assert no effects (testing)\nwith airlock.scope(policy=airlock.AssertNoEffects()):\n    pure_function()  # Raises if any enqueue() called\n\n# Block specific tasks\nwith airlock.scope(policy=airlock.BlockTasks({\"send_email\"})):\n    process_order()  # Emails dropped, other tasks execute\n\n# Log everything\nwith airlock.scope(policy=airlock.LogOnFlush(logger)):\n    do_stuff()  # All dispatches logged\n</code></pre>"},{"location":"understanding/core-model/#policy-decides","title":"Policy decides:","text":"<ul> <li>Which intents are allowed (filter)</li> <li>What to observe (logging, metrics)</li> <li>When to fail fast (assertions)</li> </ul> <p>Default: allow everything.</p>"},{"location":"understanding/core-model/#concern-3-how-executor","title":"Concern 3: HOW (Executor)","text":"<p>Executors control dispatch mechanism.</p> <pre><code># Sync execution (default)\nwith airlock.scope():\n    airlock.enqueue(my_function, arg=123)\n# Executes: my_function(arg=123)\n\n# Celery\nfrom airlock.integrations.executors.celery import celery_executor\n\nwith airlock.scope(executor=celery_executor):\n    airlock.enqueue(celery_task, arg=123)\n# Executes: celery_task.delay(arg=123)\n\n# django-q\nfrom airlock.integrations.executors.django_q import django_q_executor\n\nwith airlock.scope(executor=django_q_executor):\n    airlock.enqueue(any_function, arg=123)\n# Executes: async_task(any_function, arg=123)\n</code></pre>"},{"location":"understanding/core-model/#executor-decides","title":"Executor decides:","text":"<ul> <li>How to run the task (sync, queue, thread pool, lambda)</li> <li>What protocol to use (Celery, django-q, Huey, custom)</li> </ul> <p>Default: synchronous execution.</p>"},{"location":"understanding/core-model/#mixing-concerns","title":"Mixing Concerns","text":"<p>The power is in composition:</p> <pre><code># Transaction-aware + Celery + logging\nfrom airlock.integrations.django import DjangoScope\nfrom airlock.integrations.executors.celery import celery_executor\n\nwith airlock.scope(\n    _cls=DjangoScope,           # WHEN: after transaction.on_commit()\n    executor=celery_executor,   # HOW: via Celery\n    policy=LogOnFlush(logger)   # WHAT: log everything\n):\n    order.save()\n    airlock.enqueue(send_email, order.id)\n# Waits for commit, dispatches via Celery, logs\n</code></pre> <pre><code># Test scope + sync executor + assertion\nwith airlock.scope(\n    _cls=Scope,                      # WHEN: immediate (no transaction)\n    executor=sync_executor,          # HOW: synchronous\n    policy=AssertNoEffects()         # WHAT: fail if anything enqueued\n):\n    test_calculation()\n</code></pre> <pre><code># Migration scope + drop all + immediate\nwith airlock.scope(\n    _cls=Scope,                      # WHEN: immediate\n    executor=sync_executor,          # HOW: doesn't matter (nothing runs)\n    policy=DropAll()                 # WHAT: suppress everything\n):\n    backfill_data()\n</code></pre>"},{"location":"understanding/core-model/#mental-model","title":"Mental Model","text":"<p>Think of airlock as a buffer with three independent controls:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  airlock.enqueue(task, ...)             \u2502 \u2190 Express intent\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u25bc\n         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2502     BUFFER      \u2502 \u2190 Intent stored\n         \u2502  [intent list]  \u2502\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502          \u2502          \u2502\n        \u25bc          \u25bc          \u25bc\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502POLICY\u2502  \u2502SCOPE \u2502  \u2502EXEC  \u2502 \u2190 3 independent controls\n    \u2502      \u2502  \u2502      \u2502  \u2502      \u2502\n    \u2502WHAT? \u2502  \u2502WHEN? \u2502  \u2502HOW?  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502          \u2502          \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n                   \u25bc\n         task(*args, **kwargs) \u2190 Execution\n</code></pre> <p>Each concern is independent:</p> <ul> <li>Change WHEN without changing WHAT or HOW</li> <li>Change WHAT without changing WHEN or HOW</li> <li>Change HOW without changing WHEN or WHAT</li> </ul> <p>This separation enables powerful composition.</p>"},{"location":"understanding/core-model/#common-combinations","title":"Common Combinations","text":"Use Case Scope Policy Executor Django production <code>DjangoScope</code> <code>AllowAll</code> <code>celery_executor</code> Django test <code>Scope</code> <code>AssertNoEffects</code> <code>sync_executor</code> Migration script <code>Scope</code> <code>DropAll</code> (doesn't matter) Admin bulk operation <code>DjangoScope</code> <code>BlockTasks({\"send_email\"})</code> <code>celery_executor</code> Celery task <code>Scope</code> <code>AllowAll</code> <code>celery_executor</code> Debug mode <code>Scope</code> <code>LogOnFlush</code> <code>sync_executor</code>"},{"location":"understanding/core-model/#next","title":"Next","text":"<ul> <li>How it composes - Nested scopes and provenance</li> <li>Basic usage guide - Practical patterns</li> </ul>"},{"location":"understanding/how-it-composes/","title":"How It Composes","text":"<p>Airlock scopes nest safely. Understanding composition is key to using airlock effectively.</p>"},{"location":"understanding/how-it-composes/#the-composition-problem","title":"The Composition Problem","text":"<p>Without careful design, nested scopes create an inverse flywheel:</p> <pre><code># Your code works great \u2713\nwith TransactionScope():\n    order.save()\n    charge_payment()  # Plain function\n\n# Library adopts airlock... now it breaks \u2717\nwith TransactionScope():\n    order.save()\n    payment_lib.process(order)  # Creates nested scope!\n    # Effects escaped before transaction committed!\n</code></pre> <p>The more code adopts airlock, the less control you have. That's backwards.</p>"},{"location":"understanding/how-it-composes/#the-solution-capture-by-default","title":"The Solution: Capture by Default","text":"<p>Parent scopes have authority over nested scopes.</p> <pre><code>with TransactionScope():\n    order.save()\n    payment_lib.process(order)  # Uses airlock internally? Captured!\n    # Effects held until transaction commits \u2713\n</code></pre> <p>Nested scopes don't flush independently by default. They're captured by their parent.</p>"},{"location":"understanding/how-it-composes/#default-behavior","title":"Default Behavior","text":"<pre><code>with airlock.scope() as outer:\n    airlock.enqueue(task_a)\n\n    with airlock.scope() as inner:\n        airlock.enqueue(task_b)\n    # Inner scope exits, but task_b is CAPTURED by outer\n\n# Both task_a and task_b dispatch together here\n</code></pre> <p>This is the controlled default. Library code can't bypass your boundaries.</p>"},{"location":"understanding/how-it-composes/#why-capture-is-safe","title":"Why Capture is Safe","text":""},{"location":"understanding/how-it-composes/#compositional-atomicity","title":"Compositional Atomicity","text":"<p>Multi-step operations stay atomic even when callees use scopes:</p> <pre><code>def checkout_cart(cart_id):\n    with airlock.scope():\n        validate_inventory(cart_id)     # May use scopes internally\n        charge_payment(cart_id)         # May use scopes internally\n        send_confirmation(cart_id)      # May use scopes internally\n    # All effects dispatch atomically \u2713\n\ncheckout_cart(123)  # Safe regardless of implementation\n</code></pre>"},{"location":"understanding/how-it-composes/#transaction-safety","title":"Transaction Safety","text":"<p>All effects wait for commit:</p> <pre><code>with transaction.atomic():\n    with airlock.scope(_cls=DjangoScope):\n        order.save()\n        third_party_lib.notify(order)  # Uses airlock? Captured!\n    # Nothing dispatches yet\n# All effects dispatch after commit \u2713\n</code></pre>"},{"location":"understanding/how-it-composes/#provenance-tracking","title":"Provenance Tracking","text":"<p>Parent scopes can distinguish their own intents from captured ones:</p> <pre><code>with airlock.scope() as outer:\n    airlock.enqueue(task_a)  # Outer's own intent\n\n    with airlock.scope() as inner:\n        airlock.enqueue(task_b)  # Captured from inner\n\n    print(f\"Own: {len(outer.own_intents)}\")          # 1\n    print(f\"Captured: {len(outer.captured_intents)}\")  # 1\n    print(f\"Total: {len(outer.intents)}\")            # 2\n</code></pre> <p>This enables: - Auditing where intents came from - Different handling for own vs captured - Debugging nested behavior</p>"},{"location":"understanding/how-it-composes/#the-before_descendant_flushes-hook","title":"The <code>before_descendant_flushes</code> Hook","text":"<p>Advanced: control what happens when nested scopes exit.</p> <pre><code>class Scope:\n    def before_descendant_flushes(\n        self,\n        exiting_scope: Scope,\n        intents: list[Intent]\n    ) -&gt; list[Intent]:\n        \"\"\"\n        Called when nested scope exits.\n\n        Return intents to allow through.\n        Anything not returned is captured.\n\n        Default: return [] (capture all)\n        \"\"\"\n        return []\n</code></pre>"},{"location":"understanding/how-it-composes/#use-cases","title":"Use Cases","text":"<p>Selective capture:</p> <pre><code>class SafetyScope(Scope):\n    \"\"\"Capture dangerous tasks, allow others through.\"\"\"\n\n    def before_descendant_flushes(self, exiting_scope, intents):\n        safe = [i for i in intents if not i.dispatch_options.get(\"dangerous\")]\n        return safe\n\nwith SafetyScope():\n    with airlock.scope():\n        airlock.enqueue(safe_task)              # Allowed through\n        airlock.enqueue(\n            dangerous_task,\n            _dispatch_options={\"dangerous\": True}\n        )                                        # Captured\n    # safe_task executed \u2713\n\n# dangerous_task executes here \u2713\n</code></pre> <p>Batching:</p> <pre><code>class EmailBatchScope(Scope):\n    \"\"\"Batch emails, allow others through.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.email_batch = []\n\n    def before_descendant_flushes(self, exiting_scope, intents):\n        emails = [i for i in intents if 'email' in i.name]\n        others = [i for i in intents if 'email' not in i.name]\n\n        self.email_batch.extend(emails)  # Capture for batching\n        return others                     # Others execute now\n\nwith EmailBatchScope() as batch:\n    with airlock.scope():\n        airlock.enqueue(send_email, to=\"user1@example.com\")\n        airlock.enqueue(log_event, event=\"email_queued\")\n    # log_event executes \u2713, email captured\n\n# Send batch\nsend_batch_emails(batch.email_batch)\n</code></pre> <p>Independent scopes (opt-out of capture):</p> <pre><code>class IndependentScope(Scope):\n    \"\"\"Allow nested scopes to flush independently.\"\"\"\n\n    def before_descendant_flushes(self, exiting_scope, intents):\n        return intents  # Allow all through\n\nwith IndependentScope():\n    with airlock.scope():\n        airlock.enqueue(task)\n    # task dispatches here (not captured) \u2713\n</code></pre>"},{"location":"understanding/how-it-composes/#policy-vs-capture","title":"Policy vs Capture","text":"<p>Policy controls WHAT executes (filtering):</p> <pre><code>with airlock.scope(policy=BlockTasks({\"send_email\"})):\n    airlock.enqueue(send_email)  # Blocked - never executes\n    airlock.enqueue(log_event)   # Allowed - executes\n</code></pre> <p>Capture controls WHEN executes (timing):</p> <pre><code>with airlock.scope() as outer:\n    with airlock.scope():\n        airlock.enqueue(send_email)  # Captured - executes later\n        airlock.enqueue(log_event)   # Captured - executes later\n# Both execute here (deferred, not blocked)\n</code></pre> <p>Key difference: - Policy: intent filtered out (never executes) - Capture: intent deferred (executes later at outer scope)</p>"},{"location":"understanding/how-it-composes/#extension-points-summary","title":"Extension Points Summary","text":"<p>Control different aspects of composition:</p> Extension Point Controls Default Policy What intents are allowed <code>AllowAll()</code> <code>should_flush()</code> Whether scope flushes/discards Flush on success <code>before_descendant_flushes()</code> When nested intents execute Capture all Executor How intents execute Sync <p>These are independent and compose freely.</p>"},{"location":"understanding/how-it-composes/#mental-model","title":"Mental Model","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Outer Scope                         \u2502\n\u2502                                     \u2502\n\u2502  Own intent: task_a                 \u2502\n\u2502                                     \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502 Inner Scope                   \u2502 \u2502\n\u2502  \u2502                               \u2502 \u2502\n\u2502  \u2502  Own intent: task_b           \u2502 \u2502\n\u2502  \u2502                               \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2502         \u2502                           \u2502\n\u2502         \u2502 before_descendant_flushes()\u2502\n\u2502         \u25bc                           \u2502\n\u2502  Captured intent: task_b            \u2502\n\u2502                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u2502 flush()\n         \u25bc\n   [task_a, task_b] dispatch together\n</code></pre>"},{"location":"understanding/how-it-composes/#common-patterns","title":"Common Patterns","text":""},{"location":"understanding/how-it-composes/#pattern-1-transaction-boundary","title":"Pattern 1: Transaction Boundary","text":"<pre><code>class TransactionScope(DjangoScope):\n    def before_descendant_flushes(self, exiting_scope, intents):\n        return []  # Capture all\n\nwith transaction.atomic():\n    with airlock.scope(_cls=TransactionScope):\n        complex_operation()  # May have nested scopes\n    # Nothing dispatches yet\n# All dispatches after commit \u2713\n</code></pre>"},{"location":"understanding/how-it-composes/#pattern-2-conditional-batching","title":"Pattern 2: Conditional Batching","text":"<pre><code>class ConditionalBatchScope(Scope):\n    def before_descendant_flushes(self, exiting_scope, intents):\n        # Batch high-volume tasks, allow low-volume through\n        high_volume = [i for i in intents if i.dispatch_options.get(\"batch\")]\n        return [i for i in intents if i not in high_volume]\n\nwith ConditionalBatchScope():\n    bulk_operation()\n    # Low-volume dispatches immediately, high-volume batched\n</code></pre>"},{"location":"understanding/how-it-composes/#pattern-3-ordering-control","title":"Pattern 3: Ordering Control","text":"<pre><code>class DBBeforeCacheScope(Scope):\n    \"\"\"DB writes now, cache updates later.\"\"\"\n\n    def before_descendant_flushes(self, exiting_scope, intents):\n        db_writes = [i for i in intents if 'db' in i.name]\n        return db_writes  # Allow DB writes through now\n\nwith DBBeforeCacheScope():\n    with airlock.scope():\n        airlock.enqueue(update_cache)\n        airlock.enqueue(db_write)\n    # db_write executes \u2713, update_cache captured\n# update_cache executes here (after DB commit) \u2713\n</code></pre>"},{"location":"understanding/how-it-composes/#next","title":"Next","text":"<ul> <li>Basic usage - Practical patterns</li> <li>Nested scopes guide - Deep dive</li> <li>Custom scopes - Subclassing</li> </ul>"},{"location":"understanding/the-problem/","title":"The Problem","text":"<p>Why does airlock exist? What problem does it solve?</p>"},{"location":"understanding/the-problem/#the-dangerous-pattern","title":"The Dangerous Pattern","text":"<p>Side effects deep in the call stack are common but problematic:</p> <pre><code>class Order(models.Model):\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        if self.status == \"shipped\":\n            notify_warehouse.delay(self.id)\n            send_confirmation_email.delay(self.id)\n</code></pre> <p>This looks reasonable. The model knows when to trigger notifications. DRY principle. Encapsulated.</p> <p>But it's a trap.</p>"},{"location":"understanding/the-problem/#what-goes-wrong","title":"What Goes Wrong","text":""},{"location":"understanding/the-problem/#1-no-opt-out","title":"1. No Opt-Out","text":"<pre><code># Migration script\nfor order in Order.objects.all():\n    order.status = \"processed\"\n    order.save()  # \ud83d\udd25 Fires 10,000 warehouse notifications\n</code></pre> <p>Every save triggers the side effect. Migrations, fixtures, bulk operations, tests - everything.</p>"},{"location":"understanding/the-problem/#2-invisible-at-call-site","title":"2. Invisible at Call Site","text":"<pre><code>order.status = \"shipped\"\norder.save()  # Looks innocent\n</code></pre> <p>You can't tell from reading this that it fires tasks. You have to know to check inside <code>save()</code>.</p>"},{"location":"understanding/the-problem/#3-testing-is-painful","title":"3. Testing is Painful","text":"<p>Options: - Mock at task level \u2192 Fragile, couples tests to implementation - Run real broker \u2192 Slow - <code>CELERY_ALWAYS_EAGER=True</code> \u2192 Hides async bugs</p> <p>None are good.</p>"},{"location":"understanding/the-problem/#4-bulk-operations-explode","title":"4. Bulk Operations Explode","text":"<pre><code># Want to update 10,000 orders\nOrder.objects.filter(old_status=\"pending\").update(status=\"processed\")\n# \u2713 One query\n\n# But you have side effects in save()\nfor order in Order.objects.filter(old_status=\"pending\"):\n    order.status = \"processed\"\n    order.save()  # \ud83d\udd25 10,000 task dispatches\n</code></pre>"},{"location":"understanding/the-problem/#5-re-entrancy-hell","title":"5. Re-entrancy Hell","text":"<pre><code>class User(models.Model):\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        enrich_from_api.delay(self.id)\n\n@celery.task\ndef enrich_from_api(user_id):\n    user = User.objects.get(id=user_id)\n    data = call_external_api(user.email)\n    user.age = data['age']\n    user.income = data['income']\n    user.save()  # \ud83d\udd25 Triggers enrich_from_api again!\n</code></pre> <p>Now you're adding flags:</p> <pre><code>def save(self, *args, _skip_enrich=False, **kwargs):\n    super().save(*args, **kwargs)\n    if not _skip_enrich:\n        enrich_from_api.delay(self.id)\n</code></pre> <p>And threading them everywhere. Yikes.</p>"},{"location":"understanding/the-problem/#the-root-cause","title":"The Root Cause","text":"<p>The problem isn't where the intent is expressed.</p> <p>The problem is: 1. Effects are silent - invisible at call site 2. Effects escape immediately - no control</p>"},{"location":"understanding/the-problem/#the-standard-solution","title":"The Standard Solution","text":"<p>Move side effects to the edge:</p> <pre><code># Model stays pure\nclass Order(models.Model):\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n\n# View handles side effects\ndef ship_order(request, order_id):\n    order = Order.objects.get(id=order_id)\n    order.status = \"shipped\"\n    order.save()\n\n    # Explicit side effects\n    notify_warehouse.delay(order.id)\n    send_confirmation_email.delay(order.id)\n\n    return HttpResponse(\"OK\")\n</code></pre> <p>This works! It's explicit, controllable, testable.</p> <p>But you lose: - Encapsulation - every caller must remember to fire tasks - DRY - duplicate side effect logic across call sites - Domain knowledge - the Order doesn't express its own behavior</p>"},{"location":"understanding/the-problem/#the-airlock-solution","title":"The Airlock Solution","text":"<p>Express intent in the model, but effects don't escape immediately:</p> <pre><code>import airlock\n\nclass Order(models.Model):\n    def save(self, *args, **kwargs):\n        super().save(*args, **kwargs)\n        if self.status == \"shipped\":\n            airlock.enqueue(notify_warehouse, self.id)        # Buffered\n            airlock.enqueue(send_confirmation_email, self.id) # Buffered\n</code></pre> <p>The execution context controls what happens:</p> <pre><code># Production: effects escape\nwith airlock.scope():\n    order.status = \"shipped\"\n    order.save()\n# Effects dispatch here\n\n# Migration: suppress everything\nwith airlock.scope(policy=airlock.DropAll()):\n    order.status = \"shipped\"\n    order.save()\n# Nothing dispatches\n\n# Test: assert no effects\nwith airlock.scope(policy=airlock.AssertNoEffects()):\n    order.status = \"pending\"  # Still testable\n    order.save()              # Raises if side effects attempted\n</code></pre> <p>You get: - \u2705 Encapsulation - intent in the domain object - \u2705 DRY - define once - \u2705 Control - execution context decides - \u2705 Visibility - inspect before dispatch - \u2705 Testing - suppress or assert</p>"},{"location":"understanding/the-problem/#key-insight","title":"Key Insight","text":"<p>Airlock separates expressing intent from executing effects.</p> <p>Intent can live close to domain logic. Execution happens at boundaries you control.</p>"},{"location":"understanding/the-problem/#next","title":"Next","text":"<ul> <li>Core model - The 3 concerns (Policy/Executor/Scope)</li> <li>How it composes - Nested scopes and provenance</li> </ul>"}]}